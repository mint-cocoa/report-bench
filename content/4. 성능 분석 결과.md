# epoll과 io_uring 성능 분석 결과

## 주요 분석 결과 요약

io_uring은 epoll 대비 다음과 같은 주요 성능 이점을 제공합니다:

- **평균 33% 더 높은 TPS**: 전체 테스트 케이스에서 io_uring은 평균적으로 epoll보다 33% 더 높은 처리량을 보였습니다.
- **시스템 콜 오버헤드 118배 감소**: epoll(182.6초)에 비해 io_uring(1.5초)은 시스템 콜에 소요되는 시간이 크게 감소했습니다.
- **스레드 확장성 향상**: 스레드 수가 증가할수록 io_uring의 성능 이점이 증가하여 16 스레드에서 39% 더 높은 성능을 보였습니다.

### 4.1 처리량(TPS) 성능 분석

#### 4.1.2 전체 평균 TPS

| I/O 모델 | 평균 TPS | 비율 |
|---------|----------|------|
| epoll   | 293,805  | 100% |
| io_uring | 391,839 | 133% |

io_uring은 epoll 대비 평균적으로 **33% 더 높은 TPS**를 제공합니다.

#### 4.1.3 연결 수별 TPS 비교

<iframe src="http://192.168.31.10:3000/connection-chart" width="100%" height="400px" frameborder="0"></iframe>

| 연결 수 | epoll TPS | io_uring TPS | 차이(%) |
| ---- | --------- | ------------ | ----- |
| 1    | 11,399    | 11,494       | +1%   |
| 10   | 88,003    | 86,710       | -1%   |
| 100  | 479,992   | 579,383      | +21%  |
| 1000 | 381,818   | 649,602      | +70%  |
| 2000 | 418,282   | 578,481      | +38%  |
| 4000 | 383,335   | 445,365      | +16%  |

연결 수 1000일 때 io_uring이 epoll 대비 **가장 큰 성능 이점(70% 향상)**을 보입니다.

#### 4.1.4 스레드 수별 TPS 비교

<iframe src="http://192.168.31.10:3000/thread-chart" width="100%" height="400px" frameborder="0"></iframe>

| 스레드 수 | epoll TPS | io_uring TPS | 차이(%) |
|-----------|-----------|--------------|---------|
| 1         | 28,569    | 31,314       | +10%    |
| 2         | 54,103    | 59,663       | +10%    |
| 4         | 101,634   | 111,890      | +10%    |
| 8         | 457,031   | 607,410      | +33%    |
| 16        | 827,687   | 1,148,920    | +39%    |

스레드 수가 증가할수록 io_uring의 이점이 두드러지며, **16 스레드에서 39% 더 높은 성능**을 보입니다.

#### 4.1.5 최고 TPS 구성

<iframe src="http://192.168.31.10:3000/thread-max-tps-chart" width="100%" height="470px" frameborder="0"></iframe>

| I/O 모델 | 최고 TPS    | 구성            | 성공률 |
|---------|-------------|-----------------|--------|
| epoll   | 1,707,788   | 100 연결, 16 스레드 | 100%   |
| io_uring | 2,036,547  | 100 연결, 16 스레드 | 100%   |

두 모델 모두 동일한 구성(100 연결, 16 스레드)에서 최고 성능을 보이며, io_uring이 epoll보다 **19% 더 높은 최고 TPS**를 달성했습니다.

#### 4.1.6 성공률 비교

<iframe src="http://192.168.31.10:3000/success-rate-chart" width="100%" height="400px" frameborder="0"></iframe>

| 연결 수 | epoll 성공률(%) | io_uring 성공률(%) |
|---------|----------------|-------------------|
| 1       | 100.000        | 100.000           |
| 10      | 100.000        | 99.950            |
| 100     | 100.000        | 99.804            |
| 1000    | 99.982         | 99.918            |
| 2000    | 99.948         | 99.822            |
| 4000    | 99.870         | 99.468            |

두 시스템 모두 높은 부하에서도 우수한 성공률을 유지하나, io_uring이 epoll보다 약간 낮은 성공률을 보이는 경향이 있습니다. 그러나 연결 수 4000에서도 **99% 이상의 성공률**을 유지하고 있습니다.

### 4.2 코어별 성능 분석

#### 4.2.1 코어 수별 TPS

<iframe src="http://192.168.31.10:3000/core-performance-chart" width="100%" height="495px" frameborder="0"></iframe>

| 코어 수 | epoll TPS | io_uring TPS | 차이(%) |
|---------|-----------|--------------|---------|
| 1       | 28,569    | 31,314       | +10%    |
| 2       | 54,103    | 59,663       | +10%    |
| 4       | 101,634   | 111,890      | +10%    |
| 8       | 457,031   | 607,410      | +33%    |
| 16      | 827,687   | 1,148,920    | +39%    |

코어 수 증가에 따른 성능 향상은 스레드 수 증가와 동일한 패턴을 보입니다.

#### 4.2.2 코어 확장성 효율성(이상적인 선형 확장 대비)

<iframe src="http://192.168.31.10:3000/core-efficiency-chart" width="100%" height="495px" frameborder="0"></iframe>

| 코어 수 | epoll 효율성(%) | io_uring 효율성(%) |
|---------|----------------|-------------------|
| 1       | 100.0          | 100.0             |
| 2       | 94.7           | 95.3              |
| 4       | 88.9           | 89.3              |
| 8       | 200.0          | 242.5             |
| 16      | 181.1          | 229.3             |

8코어와 16코어에서 두 모델 모두 **초선형(super-linear) 확장성**을 보이는데, io_uring(8코어: 242.5%, 16코어: 229.3%)이 epoll(8코어: 200%, 16코어: 181.1%)보다 더 높은 효율성을 보입니다.

#### 4.2.3 코어당 TPS

<iframe src="http://192.168.31.10:3000/core-per-tps-chart" width="100%" height="470px" frameborder="0"></iframe>

| 코어 수 | epoll 코어당 TPS | io_uring 코어당 TPS | 차이(%) |
|---------|-----------------|---------------------|---------|
| 1       | 28,569          | 31,314              | +10%    |
| 2       | 27,052          | 29,832              | +10%    |
| 4       | 25,409          | 27,973              | +10%    |
| 8       | 57,129          | 75,926              | +33%    |
| 16      | 51,730          | 71,808              | +39%    |

16코어에서 io_uring의 코어당 TPS는 약 71,808로, epoll의 51,730보다 **39% 높은** 코어당 처리량을 보여줍니다.

### 4.4 시스템 콜 오버헤드 분석

#### 4.4.1 시스템 콜 비교

<iframe src="http://192.168.31.10:3000/syscall-overhead-chart" width="100%" height="535px" frameborder="0"></iframe>

| I/O 모델 | 총 소요 시간(초) | 시스템 콜 수 | 호출당 평균 시간(μs) |
|---------|----------------|-------------|---------------------|
| epoll   | 182.630277     | 16,707      | 10,931              |
| io_uring | 1.549218      | 8,187       | 189                 |

io_uring은 epoll보다 **총 시스템 콜 시간이 118배 짧으며**, 호출당 평균 시간도 **58배 빠릅니다**.

#### 4.4.2 주요 시스템 콜 분석

**epoll 주요 시스템 콜**:
1. epoll_wait: 89.43%(163.33초) - 핵심 대기 함수
2. clock_nanosleep: 9.76%(17.83초)
3. fcntl: 0.35%(0.64초)
4. accept: 0.26%(0.47초)
5. epoll_ctl: 0.20%(0.37초)

**io_uring 주요 시스템 콜**:
1. fcntl: 58.56%(0.91초)
2. clock_nanosleep: 20.75%(0.32초)
3. restart_syscall: 13.81%(0.21초)
4. io_uring_enter: 6.73%(0.10초) - 핵심 IO 함수
5. 기타: mmap, close, futex(<1%)

epoll은 **epoll_wait에서 89.43%의 시간**이 소요되는 반면, io_uring은 **io_uring_enter에서 단 6.73%의 시간**만 소요됩니다. 이는 io_uring의 비동기 배치 처리 방식의 효율성을 보여줍니다.

#### 4.4.3 트래픽 증가에 따른 시스템 콜 오버헤드

트래픽(연결 수)이 증가할수록 epoll의 시스템 콜 오버헤드는 급격히 증가하는 반면, io_uring은 상대적으로 완만하게 증가합니다. 이는 io_uring의 배치 처리 방식과 비동기 특성으로 인한 이점입니다

## 5. 결론

본 성능 분석 결과를 종합하면, io_uring은 대부분의 시나리오에서 epoll보다 우수한 성능을 보여주며, 특히 다음과 같은 특징이 두드러집니다:

1. **처리량 성능**: io_uring은 평균적으로 epoll보다 33% 더 높은 TPS를 제공하며, 최대 TPS는 약 2.04M으로 epoll(1.71M)보다 19% 더 높습니다. 특히 연결 수 1000에서 70%의 성능 향상을 보입니다.

2. **코어 활용 효율성**: io_uring은 8코어와 16코어에서 뛰어난 초선형 확장성을 보여주며, epoll보다 더 효율적인 코어 활용도를 보입니다.

3. **시스템 콜 효율성**: io_uring은 시스템 콜 오버헤드가 epoll보다 훨씬 적어, 고부하 환경에서 더 안정적인 성능을 제공합니다.

4. **스레드 확장성**: io_uring은 스레드 수가 증가할수록 epoll 대비 성능 이점이 증가하며, 특히 8 스레드 이상에서 큰 이점을 제공합니다.

이러한 결과를 고려할 때, 새로운 고성능 네트워크 애플리케이션 개발 시 io_uring을 채택하는 것이 대부분의 경우 유리하며, 특히 고부하 환경이나 다중 스레드 구성에서 io_uring의 이점이 극대화됩니다. 단, 단순한 구현이나 낮은 부하 환경에서는 epoll도 여전히 경쟁력 있는 선택지가 될 수 있습니다.
