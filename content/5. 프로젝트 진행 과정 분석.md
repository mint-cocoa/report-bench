
## 1. SessionManager 구현

세션 매니저를 도입한 주요 이유는 멀티쓰레딩 환경에서 클라이언트 분배 및 세션 관리시에서 효율성을 위함이었습니다.

SessionManager 구현 전엔 메인 루프에서 각 쓰레드들에 세션들을 할당해 코드 가독성과 클라이언트 분배 관리에 문제점이 있었습니다.

SessionManager를 구현험으로써  세션 할당시 로직  변경시 세션 매니져의 코드만 수정하면 되므로 유지보수성이 향상될 것으로 기대되어 구현하게 되었습니다. 또한:

1. **세션 격리**: 각 세션은 독립적인 워커 스레드에서 실행되므로, 한 세션의 문제가 다른 세션에 영향을 미치지 않습니다.
2. **확장성**: 서버 성능을 높이려면 세션 수(스레드 수)만 늘리면 되는 구조적 유연성을 제공합니다.
3. **중앙화된 관리**: 클라이언트-세션 매핑 정보를 중앙에서 관리하므로 클라이언트 이동이나 세션 재배치가 용이합니다.

와 같은 이점을 얻을수 있게 될 것이라고 판단했습니다.

## 2. Listener 클래스 구현 

Listener 클래스가 없을땐 연결 수락과 데이터 처리 로직이 하나의 클래스에 섞여 코드 가독성이 좋지 않았습니다. 
또한 연결 수락과 데이터 처리 로직이 하나의 클래스에 섞여 코드 가독성이 저하되고, 새 연결 수락과 기존 클라이언트 데이터 처리가 동일한 이벤트 루프에서 처리되어, accept 요청 부하시 데이터 처리가 지연되었습니다.

 Listener 클래스 도입 후 연결 수락은 Listener가, 데이터 처리는 Session이 담당하게 분리했습니다.
- **최적화된 이벤트 루프**: Listener는 accept 작업에 최적화된 이벤트 루프를, Session은 read/write에 최적화된 이벤트 루프를 각각 운영할 수 있습니다.
- **독립적 확장**: 연결 수락 부하에 따라 Listener 성능만 별도로 조정할 수 있습니다.
- **싱글톤 패턴**: Listener를 싱글톤으로 구현하여 전체 시스템에서 접근이 용이하고 일관된 관리가 가능합니다.

구현에서 `Listener`는 `epoll_instance_` 또는 `io_ring_`을 전용으로 사용하여 ACCEPT 이벤트만 처리하고, 수락된 클라이언트는 `SessionManager`를 통해 적절한 `Session`으로 분배합니다. 이렇게 하면 연결 수락 처리가 데이터 처리 로직에 영향을 주지 않아 전체 시스템의 응답성이 향상됩니다.

## 3. 버퍼 관리 전략의 변경

초기에 모든 세션이 하나의 버퍼 풀을 공유하는 설계에서 각 인스턴스가 자체 버퍼를 보유하는 방식으로 변경한 이유는 다음과 같습니다:

**변경 전 (공유 버퍼):**

- **동기화 오버헤드**: 여러 스레드가 동일한 버퍼 풀에 접근할 때 락(mutex)이 필요해 성능 저하가 발생했습니다.
- **경합(Contention)**: 부하가 높은 상황에서 버퍼 할당/해제 시 스레드 간 경합이 심해져 스레드가 대기 상태에 머무는 시간이 늘어났습니다.


**변경 후 (인스턴스별 버퍼):**

- **락 프리(Lock-free) 구현**: 각 io_uring 인스턴스가 자체 버퍼를 관리하므로 스레드 간 동기화가 필요 없어졌습니다.
- **지역성(Locality) 향상**: 스레드가 자신의 버퍼만 사용하므로 CPU 캐시 효율이 증가했습니다.
- **확장성**: 스레드 수가 늘어나도 버퍼 관리 성능이 선형적으로 저하되지 않는 확장성을 확보했습니다.
- **메모리 친화적 설계**: io_uring과 버퍼 관리자를 같은 인스턴스에 두어 메모리 지역성을 개선했습니다.

구체적으로 `Session` 클래스에서 각 세션이 자체 `io_ring_` 객체를 가지고, 이 객체가 `buffer_manager_`를 관리하도록 변경했습니다. 이로 인해 io_uring을 사용할 때 중요한 thread-safety 문제도 함께 해결되었습니다.

## 4. 소켓을 파일 디스크립터에서 래핑된 포인터로 관리

**파일 디스크립터 직접 사용 시 문제점:**

- **리소스 누수**: 연결 종료 시 명시적인 close() 호출을 잊으면 파일 디스크립터 누수가 발생합니다.
- **중복 코드**: 소켓 작업(바인딩, 리스닝, 비블로킹 설정 등)을 위한 코드가 여러 곳에 중복됩니다.
- **안전성 부족**: 잘못된 fd를 사용하거나 이미 닫힌 fd에 접근하는 오류를 방지하기 어렵습니다.

**SocketPtr(Socket 클래스 래핑) 사용 시 장점:**

- **RAII 원칙 적용**: 소켓이 스코프를 벗어날 때 자동으로 close()되어 리소스 누수를 방지합니다.
- **캡슐화**: 소켓 관련 상태와 작업이 하나의 클래스에 캡슐화되어 관리가 용이합니다.
- **타입 안전성**: 컴파일 시간에 타입 검사를 통해 많은 오류를 방지할 수 있습니다.
- **확장성**: 소켓 관련 기능(TCP/UDP 전환)을 Socket 클래스에 추가하기 쉽습니다.
- **유효성 검사**: `isValid()` 같은 메서드로 소켓 상태를 쉽게 확인할 수 있습니다.
- **인터페이스 일관성**: `bind()`, `listen()`, `accept()` 등의 메서드가 일관된 인터페이스로 제공됩니다.

구현에서는 `std::shared_ptr<Socket>`(SocketPtr)을 사용하여 소켓의 수명을 관리하고, Socket 클래스의 소멸자에서 자동으로 close()를 호출하도록 했습니다. 이를 통해 파일스크립터가 닫히지 않는 상황에서도 자동으로 자원이 해제될 수 있습니다. 




