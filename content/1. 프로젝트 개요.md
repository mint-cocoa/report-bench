

## 1.1  배경 및 목적

Linux 운영체제에서 사용되는 두 가지 I/O 모델인 전통적인 `epoll`과 linux 커널의 새 I/O api `io_uring`의 성능을 비교한 결과 및 서버 구현 과정에 대해 분석하고 설명하는 문서입니다 . 

이중 io_uring이 리눅스os에서 epoll 에 비해 가질수 있는 이점에 대해 파악하고 이벤트 기반의 io 처리 방식에 대해 공부하기 위해 해당 프로젝트를 진행했습니다. 

### 1.2 I/O 모델 소개

#### epoll

`epoll`은 리눅스에서 오랫동안 사용된 I/O 모델로 여러 디스크립터를 모니터링하여 I/O가 가능한 상태인지 확인하는 방식입니다. 
#### io_uring

`io_uring`은 2019년 리눅스 커널 5.1에 도입된 고성능 비동기 I/O 프레임워크로,  높은 처리량과 낮은 지연 시간을 필요로 하는 애플리케이션을 위해 최적화 되었습니다.

**기본 개념과 아키텍처:**

`io_uring`의 가장 중요한 점은 사용자 공간과 커널 공간 사이에 두 개의 lock-free 링 버퍼를 공유한다는 점입니다.

1. **제출 큐(Submission Queue, SQ)**: 애플리케이션이 수행하고자 하는 I/O 작업들을 커널에 전달하는 데 사용됩니다.
2. **완료 큐(Completion Queue, CQ)**: 커널이 완료된 I/O 작업의 결과를 애플리케이션에 반환하는 데 사용됩니다.

이 두 큐는 메모리 매핑 을 통해 사용자 공간과 커널 공간 사이에 공유되어, 시스템 콜 오버헤드를 최소화하고 데이터 복사를 줄입니다.

**작동 방식:**

1. **초기화**: `io_uring_setup()` 시스템 콜을 통해 io_uring 인스턴스를 생성합니다. 이때 SQ와 CQ의 크기를 지정할 수 있습니다.
2. **I/O 요청 제출**:
    - 애플리케이션은 SQ에 I/O 요청을 직접 작성합니다.
    - 여러 I/O 요청을 배치로 준비한 후, `io_uring_enter()` 시스템 콜을 한 번 호출하여 모든 요청을 커널에 알립니다.
3. **I/O 완료 처리**:
    - 커널은 I/O 작업이 완료되면 그 결과를 CQ에 작성합니다.
    - 애플리케이션은 CQ를 주기적으로 폴링하여 완료된 작업을 확인합니다.
4. **버퍼 관리**: 
    - 버퍼 등록: 자주 사용하는 버퍼를 사전에 등록하여 매 I/O 작업마다 주소 변환이 필요하지 않도록 합니다.
    - 버퍼 링: 버퍼 풀을 관리하여 효율적으로 메모리 재사용이 가능합니다.


### 1.3 테스트 방법론 개요

 다음과 같은 방법으로 io_uring을 서버에 적용하고 성능 평가했습니다.

1. 기본 tcp echo 서버 구현
    - 다중 클라이언트 접속 및 멀티쓰레딩 환경 구축
2. io_uring  및 epoll 적용 서버 구조 설계
    - 스레드별 io_uring 및 epoll 객체 생성
3. 성능 평가 방법
    - stress 테스트용 클라이언트를 이용한 코드 작성 및 수정
    - 시스템 콜 호출 횟수, 처리량, 응답 시간 측정
    - 동시 접속자 수에 따른 성능 변화 분석

